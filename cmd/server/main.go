/*
Copyright 2020 The Kubernetes Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"encoding/csv"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"

	"github.com/prometheus/client_golang/prometheus/promhttp"
	flag "github.com/spf13/pflag"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"sigs.k8s.io/aws-encryption-provider/pkg/cloud"
	"sigs.k8s.io/aws-encryption-provider/pkg/healthz"
	"sigs.k8s.io/aws-encryption-provider/pkg/livez"
	"sigs.k8s.io/aws-encryption-provider/pkg/logging"
	"sigs.k8s.io/aws-encryption-provider/pkg/plugin"
	"sigs.k8s.io/aws-encryption-provider/pkg/server"
)

func main() {
	var (
		healthPort         = flag.String("health-port", ":8080", "port to serve /healthz and /livez")
		healthzPath        = flag.String("healthz-path", "/healthz", "deep health check path")
		livezPath          = flag.String("livez-path", "/livez", "liveness/connectivity check path")
		addrs              = flag.StringSlice("listen", []string{"/var/run/kmsplugin/socket.sock"}, "comma separated list of GRPC listen address")
		keys               = flag.StringSlice("key", []string{""}, "comma separated list of AWS KMS Keys")
		healthKms          = flag.String("health-kms-version", "v1", "kms version to use for health checks. Valid options: v1, v2")
		region             = flag.String("region", "", "AWS Region")
		kmsEndpoint        = flag.String("kms-endpoint", "", "use this KMS endpoint instead of the one generated by AWS sdk")
		qpsLimit           = flag.Int("qps-limit", 0, "(deprecated) number of requests per second to allow for KMS API calls (0 to not rate limit), use --retry-token-capacity instead")
		burstLimit         = flag.Int("burst-limit", 0, "(deprecated) number of tokens that can be consumed in a single call, use --retry-token-capacity instead")
		retryTokenCapacity = flag.Int("retry-token-capacity", 0, "number of tokens for client-side AWS rate-limiting on retries")
		encryptionCtxsArr  = flag.StringArray("encryption-context", []string{}, "AWS KMS Encryption Context (e.g. 'a=b,c=d')")
		debug              = flag.Bool("debug", false, "Print debug level logs")
	)
	flag.Parse()

	encryptionCtxs := []map[string]string{}
	for _, encryptionCtxStr := range *encryptionCtxsArr {
		encryptionCtx, err := stringToStringConv(encryptionCtxStr)
		if err != nil {
			fmt.Fprintf(os.Stderr, "failed to parse encryption-context: %v", err)
			os.Exit(1)
		}
		encryptionCtxs = append(encryptionCtxs, encryptionCtx.(map[string]string))
	}

	if len(*keys) != len(*addrs) {
		fmt.Fprintf(os.Stderr, "key and listen lists must have the same number of elements")
		os.Exit(1)
	}

	logLevel := zapcore.InfoLevel
	if *debug {
		logLevel = zapcore.DebugLevel
	}

	l, err := logging.NewStandardLogger(logLevel)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to configure logging")
		os.Exit(1)
	}

	zap.ReplaceGlobals(l)

	zap.L().Info("creating kms server",
		zap.String("health-port", *healthPort),
		zap.String("healthz-path", *healthzPath),
		zap.String("health-kms-version", *healthKms),
		zap.String("livez-path", *livezPath),
		zap.String("region", *region),
		zap.Strings("listen-address", *addrs),
		zap.String("kms-endpoint", *kmsEndpoint),
		zap.Int("qps-limit", *qpsLimit),
		zap.Int("burst-limit", *burstLimit),
		zap.Int("retry-token-capacity", *retryTokenCapacity),
	)
	c, err := cloud.New(*region, *kmsEndpoint, *qpsLimit, *burstLimit, *retryTokenCapacity)
	if err != nil {
		zap.L().Fatal("Failed to create new KMS service", zap.Error(err))
	}

	for i, encryptionCtx := range encryptionCtxs {
		for k, v := range encryptionCtx {
			zap.L().Info("encryption-context", zap.Int("index", i), zap.String("key", k), zap.String(
				"value", v))
		}
	}

	sharedHealthCheck := plugin.NewSharedHealthCheck(plugin.DefaultHealthCheckPeriod, plugin.DefaultErrcBufSize)
	go sharedHealthCheck.Start()
	defer sharedHealthCheck.Stop()

	servers := []*server.Server{}
	p1s := []*plugin.V1Plugin{}
	p2s := []*plugin.V2Plugin{}

	for i, key := range *keys {
		s := server.New()
		servers = append(servers, s)
		encryptionCtx := getOrDefault(encryptionCtxs, i, map[string]string{})

		p := plugin.New(key, c, encryptionCtx, sharedHealthCheck)
		p.Register(s.Server)
		p2 := plugin.NewV2(key, c, encryptionCtx, sharedHealthCheck)
		p2.Register(s.Server)
		if *healthKms == "v1" {
			p1s = append(p1s, p)
		}
		if *healthKms == "v2" {
			p2s = append(p2s, p2)
		}
	}

	go func() {
		http.Handle(*healthzPath, healthz.NewHandler(p1s, p2s))
		http.Handle(*livezPath, livez.NewHandler(p1s, p2s))
		http.Handle("/metrics", promhttp.Handler())
		if err := http.ListenAndServe(*healthPort, nil); err != nil {
			zap.L().Fatal("Failed to start healthcheck server", zap.Error(err))
		}
	}()
	zap.L().Info("Healthchecks server started", zap.String("port", *healthPort))

	for i, addr := range *addrs {
		s := servers[i]

		go func() {
			if err := s.ListenAndServe(addr); err != nil {
				zap.L().Fatal("Failed to start server", zap.Error(err))
			}
		}()

		zap.L().Info("Plugin server started", zap.String("port", addr))
	}

	signals := make(chan os.Signal, 1)
	signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)

	signal := <-signals

	zap.L().Info("Received signal", zap.Stringer("signal", signal))
	zap.L().Info("Shutting down server")
	for _, s := range servers {
		s.GracefulStop()
	}
	zap.L().Info("Exiting...")
	os.Exit(0)
}

// get index in array or return default value if out of index
func getOrDefault[T any](arr []T, index int, defaultVal T) T {
	if index >= len(arr) || index < 0 {
		return defaultVal
	}
	return arr[index]
}

// parses string into map[string]string
// based on plog's stringToString implementation
func stringToStringConv(val string) (interface{}, error) {
	val = strings.Trim(val, "[]")
	// An empty string would cause an empty map
	if len(val) == 0 {
		return map[string]string{}, nil
	}
	r := csv.NewReader(strings.NewReader(val))
	ss, err := r.Read()
	if err != nil {
		return nil, err
	}
	out := make(map[string]string, len(ss))
	for _, pair := range ss {
		kv := strings.SplitN(pair, "=", 2)
		if len(kv) != 2 {
			return nil, fmt.Errorf("%s must be formatted as key=value", pair)
		}
		out[kv[0]] = kv[1]
	}
	return out, nil
}
